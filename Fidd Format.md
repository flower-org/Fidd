# Fidd - Формат fidd-файла.

Для начала определим, что же из себя представляет данный формат, и для чего он предназначается.
Fidd-файл представляет из себя запакованную и зашифрованную директорию с файлами и поддиректориями, либо обновление к структуре существующего fidd-файла.
Принципиально, строение оригинального fidd-файла или же fidd-обновления не отличается, разница лишь в метаданных, т.к. в оригинальном файле по определению не может существовать diff-ов.
Поэтому более подробно на специфике обновлений остановимся позже, при разборе структуры метаданных, а здесь для начала опишем базовую структуру fidd-файла.


## 1. Требования к fidd-файлам

Как уже было сказано, fidd-файл логически представляет из себя директорию с поддиректориями и файлами.
Расмотрим требования, которым должен отвечать этот формат. 

1.1 Шифрование данных
Fidd-файл хранит все данные зашифрованными, то есть для их чтения потребуются ключи для расшифровки.
Так как данные зашифрованы (и если такая опция используется), то без знания ключей не должно представляться не только возможности прочитать непосредственно контент этих файлов, но также формат не должен допускать никаких metadata leaks, т.е. хранение в открытом виде информации о структуре директорий, файлов, их количестве, размерах, в т.ч. общем размере, оффсетах на которых они хранятся и т.д.
В том числе, если доступ есть только к некоторым файлам, то даже имея частичный доступ, не должно быть возможности сделать заключение об общем количестве файлов, включая те, к которым нет доступа, или их размерах.
При этом, некоторые файлы можно хранить в открытом виде, то есть незашифрованными, в таком случае для их чтения ключи не потребуются.

1.2 Сжатие данных
Fidd может хранить любые BLOB-ы или файлы, в том числе предварительно сжатые, и дожен поддерживать информацию не только о формате сжатия в метаданных, однако сам не является архиватором или разархиватором, и не поддерживает связанную со сжатием функциональность. Таким образом сжимать или архивировать данные необходимо до запаковки их в формат fidd, и соответственно, после распаковки потребуется их разархивировать, за что сам fidd не отвечает.
Помимо того, что мы избегаем ненужного усложнения формата, нелогично навязывать сжатие, например, для медиа-файлов, как OGG/MP3 или видео-форматов, которые и так оптимальны в плане сжатия данных.

1.3 Возможность стриминга данных
Fidd-формат должен поддерживать возможность стриминга отдельных файлов через стандартные сетевые файловые сервисы. При этом речь идет о базовых файловых операциях чтения с оффсетом над Fidd файлом, т.е. сам сервис может быть вполне стандартным FTP или HTTP 3rd party файл-хостом и не обязан ничего знать ни о самом формате fidd, ни тем более о ключах шифрования.
Заметим, что по действиям клиента-чтеца файлов, и если файл-хост сервис ведет логи операций, то нельзя исключить, что из подобных логов можно будет сделать пусть частичные, но выводы о количестве и оффсетах, на которых расположены файлы.
На высших уровнях секьюрности даже подобный metadata leak может считаться недопустимым. Поэтому в самых чувствительных use case-ах вместо стриминга с оффсетов рекомендуем использовать полное скачивание всего fidd файла, и локальную работу с ним.
По этой причине мы также разработаем собственную многоуровневую модель сервисного API, в которой самая первая и базовая модель не будет иметь функций запроса данных с оффсетом, а только полность всего файла.
Для повседневного же использования стриминг, несмотря на metadata leak опасность, вполне допустим, и даже очень удобен, позволяя, например, использовать streaming-only модель, без локального хранения контента.
Заметим, что хотя опасность такого netadata leak и реальна, но последствия его минимальны, т.к. весь чувствительный контент так или иначе будет храниться и передаваться в зашифрованном виде.


## 2. Пару слов о шифровании

Очевидно, что очень большой упор в этом формате мы делаем на безопасность и шифрование. Поэтому логично, что в самом fidd-файле никаких ключей расшифровки, даже зашифрованных, мы бы не хотели хранить.
Также, учитывая приведенные выше требования о частичном доступе, мы не может использовать один ключ для всех файлов, т.к. в этом случае мы либо даем доступ ко всему, либо ни к чему. А также мы не сможем часть файлов хранить в открытом виде.
Отсюда логичное требование, каждый логический файл криптовать своим ключом, что также более секьюрно.
Также добавлю, что на уровне fidd-формата файлы не могут иметь никаких ссылок друг на друга, чтобы исключить возможность получения информации об иных файлах имея доступ только к одному из них.
Если же подобная информация будет храниться в самом контенте файлов, то референсинг будет осуществляться через механизмы не связанные напрямую с fidd-форматом, например по имени или пути файла.

2.1 Управление ключами расшифровки
Таким образом, ключи шифрования должны храниться вне fidd-файла. Так как мы имеем дело со структурой определенной сложности, для чтения которой требуется зание множества ключей и кое-каких метаданных, удобнее всего данную информацию также сгруппировать.
Для этого мы планируем использовать fidd.key файлы, которые будут иметь собственный lifecycle и не обязательно должны находиться на тех же хостах или распространяться через те же каналы, что и сами fidd-файлы.
В файле fidd.key, для каждого логического файла, к которому разрешен доступ мы будем хранить помимо собственно ключа расшифровки также и информацию об оффсетах логического файла. 

2.2 Используемые алгоритмы
Fidd-формат не предписывает использования тех или иных алгоритмов шифрования. Несмотря на то, что мы подразумеваем индустриальный стандарт наших дней, AES-256, нет ничего в Fidd-формате, что запрещало бы использовать альтернативные алгоритмы, или даже вместо самих ключей хранить некие референсы на них. Более того, Fidd-формату по сути безразлично, откуда пользователь возьмет информацию об используемом алгоритме, это в принципе может быть обговорено заранее и являться секретом.
Поэтому, в файле fidd.key будет опциональное поле для спецификации алгоритма шифрования для каждого файла, по сути строка свободного формата. Повторюсь, что т.к. поле опциональное, в принципе, указывать алгоритм необязательно.


## 3. Формат Fidd-файла

3.1 Метаданные файла

Говоря о хранении логических файлов, мы говорим не просто о хранении контента (собственно данных), но также о хранении метаданных, привязанных к этому файлу.
На данном этапе видятся важными такие поля, как:
- размер секции метаданных;
- (возможно?) размер данных / длина контента;
- новый файл или тип diff-а (например, есть текстовый diff, binary diff, и, наверное, много что еще) 
- имя файла;
- путь к файлу;
- дата создания;
- дата изменения;
- тип данных файла;
- тип сжатия файла;

Мы сгруппируем эту информация в отдельный BLOB и будем хранить, как префикс файла, перед его контентом. 
(Возможно, безопаснее будет хранить, как постфикс, но читать тогда не очень удобно, тогда в fidd.key нужно будет хранить и размер контента. TODO: подумать над этим)

3.2 Контент файла 

Мы выбираем простоту и храним контент единым куском, 

3.3 Офсеты, и борьба с возмжностью предсказания офсетов и размера содержащихся в fidd-файле данных.


## 4. Формат файла fidd.key

Файл fidd.key прежде всего должен будет хранить значение:

- версия fidd формата

А также, как уже было описано выше, массив объектов следующей структуры, по объекту для каждого файла:

- ключ шифрования файла (возможна структура, например, ключ + IV)
- оффсет файла (опционально - длина файла?)
- (опционально) алгоритм шифрования

Данная информация позволит, имея fidd-файл, получить из него и расшифровать логический файл и его метаданные.


## 5. Запаковщик и распаковщик

фвыфыв


## 6. Развитие формата

Данный документ описывает общие требования и отдельные предложения к иплементации формата fidd, но не является законченным техническим стандартом, и это умышленно.
Более того, мы не исключаем, что данный формат может пройти несколько эволюционных шагов, поэтому имеет смысл говорить именно о версиях формата.
Наш эффорт, направленный на реализацию версии, следующей принципам описанным в данном документе, мы назовем fidd 1.0.
Из секции 4 видно, что в целях безопасности сам fidd-файл не будет даже хранить версии своего формата, данная информация будет находиться в fidd.key.
Действительно, какой толк знать версию формата файла без ключа, которым этот формат открывается.

Возможно также отдельное версионирование формата fidd, fidd.key и file metadata. Тогда общая версия формата будет составной.
Например, `1.0:1.0:2.5`
- формат fidd-файла 1.0
- формат fidd.key-файла 1.0
- формат file metadata 2.5
