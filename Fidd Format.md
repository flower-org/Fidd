# Fidd - Формат fidd-файла.

Для начала определим, что же из себя представляет fidd-формат, и для чего он предназначается.

Fidd-файл представляет из себя запакованную и зашифрованную директорию с файлами и поддиректориями, либо обновление к структуре существующего fidd-файла.  
Принципиально, строение оригинального fidd-файла или же fidd-обновления не отличается, разница лишь в метаданных, т.к. в оригинальном файле по определению не может существовать diff-ов.

Поэтому более подробно на специфике обновлений остановимся позже, при разборе структуры метаданных, а начнем с описания базовой структуры fidd-файла.


## 1. Требования к fidd-файлам

Как уже было сказано, fidd-файл логически представляет из себя директорию с поддиректориями и файлами.  
Расмотрим требования, которым должен отвечать этот формат. 

### 1.1 Шифрование данных

Fidd-файл хранит все данные зашифрованными, то есть для их чтения потребуются ключи для расшифровки.  
Так как данные зашифрованы (и если такая опция используется), то без знания ключей не должно представляться не только возможности прочитать непосредственно контент этих файлов, но также формат не должен допускать никаких metadata leaks, т.е. хранение в открытом или легкодоступном виде информации о структуре директорий, файлов, их количестве, размерах, в т.ч. общем размере, оффсетах на которых они хранятся и т.д.  

Также, если доступ есть только к некоторым файлам, то даже имея частичный доступ, не должно быть возможности сделать выводы об общем количестве файлов, в частности тех, к которым нет доступа, или их размерах.  
При этом, некоторые файлы можно хранить в открытом виде, то есть незашифрованными, в таком случае для их чтения ключи не потребуются.

### 1.2 Сжатие данных

Fidd может хранить любые BLOB-ы или файлы, в том числе предварительно сжатые, и должен поддерживать информацию о формате сжатия в метаданных, однако сам не является архиватором или разархиватором, и не поддерживает связанную со сжатием функциональность. Таким образом сжимать или архивировать данные необходимо до запаковки их в формат fidd, и соответственно, после распаковки потребуется их разархивировать, за это сам fidd не отвечает.  
Помимо того, что этим мы избегаем ненужного усложнения формата, нелогично навязывать сжатие, например, для медиа-файлов, как OGG/MP3 или видео-форматов, которые оптимальны не только в плане сжатия данных, но и для стриминга.

### 1.3 Возможность стриминга данных

Fidd-формат должен поддерживать возможность стриминга отдельных файлов со стандартных сетевых файловых сервисов.  
При этом речь идет о базовых файловых операциях чтения с оффсетом над Fidd файлом, т.е. сам сервис может быть вполне стандартным FTP или HTTP 3rd party файл-хостом и не обязан ничего знать ни о самом формате fidd, ни тем более о ключах шифрования.  

Заметим, что если файл-хост сервис ведет логи операций / действий клиента-чтеца файлов, то нельзя исключить, что из подобных логов можно будет сделать пусть неполные, но выводы о количестве файлов и оффсетах, на которых расположены файлы.
На высших уровнях секьюрности даже подобный metadata leak может считаться недопустимым. Поэтому в самых чувствительных use case-ах вместо стриминга с оффсетов рекомендуем использовать полное скачивание всего fidd файла, и локальную работу с ним.
По этой причине мы также планируем разработать собственную многоуровневую модель сервисного API, в которой самая первая и базовая (а потому и самая безопасная) модель не будет иметь функций получения данных с оффсета, а только скачивание полностью всего файла.  

Для повседневного же использования стриминг, несмотря на metadata leak опасность, вполне допустим, и даже очень удобен, позволяя, например, использовать streaming-only модель, без локального хранения контента.
Заметим также, что хотя опасность вышеописанного metadata leak и реальна, но последствия его минимальны, т.к. весь чувствительный контент так или иначе будет храниться и передаваться в зашифрованном виде.


## 2. Пара слов о шифровании

Очевидно, что очень большой упор в этом формате мы делаем на безопасность и шифрование. Поэтому логично, что в самом fidd-файле мы бы не хотели хранить никаких ключей расшифровки, даже зашифрованных.
Также, учитывая приведенные выше требования о частичном доступе, мы не может использовать один ключ для всех файлов, т.к. в этом случае мы либо даем доступ ко всему, либо ни к чему. А также мы не сможем часть файлов хранить в открытом виде.  
Отсюда требование - каждый логический файл криптовать своим ключом, что также более секьюрно.

Еще добавлю, что на уровне fidd-формата файлы не могут иметь никаких ссылок друг на друга, чтобы исключить возможность получения информации об иных файлах имея доступ только к одному из них.
Если же подобная информация будет храниться в самом контенте файлов, то референсинг будет осуществляться через механизмы не связанные напрямую с fidd-форматом, например по имени/пути логического файла.

### 2.1 Управление ключами расшифровки

Таким образом, ключи шифрования должны храниться вне fidd-файла. Так как мы имеем дело со структурой определенной сложности, для чтения которой требуется знание множества ключей и кое-каких метаданных, удобнее всего данную информацию также сгруппировать.

Для этого мы планируем использовать fidd.key файлы, которые будут иметь собственный lifecycle и не обязательно должны находиться на тех же хостах или распространяться через те же каналы, что и сами fidd-файлы.
В файле fidd.key, для каждого логического файла, к которому разрешен доступ мы будем хранить помимо собственно ключа расшифровки также и информацию об оффсетах логического файла. 

### 2.2 Используемые алгоритмы

Fidd-формат не предписывает использования тех или иных алгоритмов шифрования. Несмотря на то, что мы подразумеваем индустриальный стандарт наших дней, AES-256, нет ничего в Fidd-формате, что запрещало бы использовать альтернативные алгоритмы, или даже вместо самих ключей или имен алгоритмов хранить некие референсы на них. Более того, Fidd-формату по сути безразлично, откуда пользователь возьмет информацию об используемом алгоритме, это в принципе может быть установлено заранее и являться пользовательским секретом.

Поэтому, в файле fidd.key будет опциональное поле для спецификации алгоритма шифрования для каждого файла, по сути строка свободного формата. Повторюсь, что т.к. поле опциональное, в принципе, указывать алгоритм необязательно, но тогда самому пользователю надо будет знать, как это расшифровать.


## 3. Формат Fidd-файла

### 3.1 Метаданные файла

Говоря о хранении логических файлов, мы говорим не просто о хранении контента (собственно данных), но также о хранении метаданных, привязанных к этому файлу.
На данном этапе видятся важными такие поля, как:
- размер секции метаданных;
- полный ли это файл (create/overrride) или же | тип diff-а (в этом случае нужны нестандартные diff-форматы, позволяющие эффективный стриминг) | или же delete флаг (файл был удален в обновлении);
- тип данных файла;
- дата создания;
- дата изменения;
- (опционально) тип сжатия файла (zip, rar, 7z, etc);

Мы сгруппируем эту информацию в отдельный BLOB и будем хранить, как префикс файла, перед его контентом.  
(Возможно, безопаснее будет хранить, как постфикс, но читать будет не очень удобно, ведь тогда в fidd.key нужно будет хранить и размер контента. TODO: подумать над этим)
(Можно хранить, как постфикс, а в fidd.key хранить ссылку на метаданные)
(Нет нельзя, с CBC)
(Вообще, с рандомными гепами, хранение в префиксе не проблема)

### 3.2 Контент файла 

Мы выбираем простоту и храним каждый логический файл единым куском, во всяком случае в версии 1.0.
Таким образом, у каждого файла будет свой оффсет, с которого будут начинаться его данные (зашифрованные, конечно же), и дальше эти данные будут идти сплошным куском, без interlacing или прочих усложнений, которые мы на данном этапе видим чрезмерными.

### 3.3 Оффсеты, и борьба с возможностью предсказания оффсетов файлов, а также размера содержащихся в fidd-файле данных.

Если наивно хранить все файлы сконкатенированными, то можно сделать следующие предсказания:
- на позиции 0 в fidd-файле обязательно будет начало логического файла;
- любая позиция в fidd-файле будет непременно указывать на валидные данные, не на рандомный мусор (т.к. рандомного мусора просто не будет);
- байт, следующий после последнего байта известного вам логического файла всегда будет являться первым байтом другого логического файла (кроме последнего, после которого ничего не следует);
- если между двумя известными вам логическими файлами gap, на который у вас нет ключа, в нем должен быть как минимум 1 файл;
- размер Fidd-файла будет примерно равен общему размеру логических файлов, из которых он состоит (с поправкой на метаданные).

Не желая строить из себя криптографов, скажем просто, что мы не исключаем того, что утечки такой информации могут вызвать проблемы или стать недостающим звеном в sophisticated crypto attack.  
Как именно - уточнять не будем, но очевидно, что в идеальном случае таких утечек метаданных быть не должно.

Поэтому мы намеренно не устанавливаем требования последовательного расположения файлов, или начала данных с позиции 0, но и не запрещаем подобное расположение.
Как описано в секции 4, fidd.key хранит оффсет для каждого логического файла, поэтому логические файлы можно расположить произвольно (естественно, избегая overlap-ов), заполнив все gap-ы случайными данными, также создав хедер и футер из рандомных байтов.
При использовании такого sparse-расположения и внедрении в структуру fidd-файла footer, header и gap-ов c рандомными байтами между файлами, произвести вышеописанные предсказания станет крайне затруднительно.


## 4. Формат файла fidd.key

Файл fidd.key должен хранить значения:

- версия fidd формата (см секцию 6 о версии форматов)
- идентификатор fidd-поста (для правильного матчинга постов-обновлений)
- версия / номер истории
- предыдущая версия (для правильного применения последовательности постов-обновлений)
- squash флаг - если пост был перепакован и должен читаться как новый
- delete флаг - если пост должен считаться удаленным

А также, как уже было описано выше, массив объектов следующей структуры, содержащий по объекту для каждого доступного пользователю файла:

- путь к файлу / имя файла (diff будет обновлять соответствующий файл);
- оффсет файла 
- длина файла (метаданные + контент)
- (опционально) ключ шифрования файла (возможна структура, например, ключ + IV)
- (опционально) алгоритм шифрования
- (опционально) CRC файла

Данная информация позволит, имея fidd-файл, получить из него и расшифровать логический файл и его метаданные.

TODO: Также рассмотреть возможность хранения больших fidd-файлов в несколько частей на файловых системах с ограниченным размером файлов, например, как FAT32 (max 4 Gb).


## 5. Fidd Packer - запаковщик и распаковщик

Первым deliverable для данного формата мы видим Fidd Packer - утилиту для запаковки и распаковки fidd-файлов.

### 5.1 Запаковка

- Получив на вход директорию, создает {fidd-файл и fidd.key-файл}.
- ??? Получив на вход оригинальную директорию и обновленную директорию, создает {fidd-файл и fidd.key-файл обновления}. (Какой присвоить номер истории?)
- Получив на вход оригинальные {fidd-файл, fidd.key-файл} и обновленную директорию, создает {fidd-файл и fidd.key-файл обновления}.
- Получив на вход оригинальные {fidd-файл, fidd.key-файл}, []{fidd-файл и fidd.key-файл обновлений} и обновленную директорию, создает {fidd-файл и fidd.key-файл обновления}.

### 5.2 Распаковка

- Получив на вход {fidd-файл и fidd.key-файл}, восстанавливает директорию.
- ??? Получив на вход оригинальную директорию и []{fidd-файл и fidd.key-файл обновлений}, обновляет оригинальную директорию. (Что если другое обновление между не было сделано? Файлы закорраптятся?)
- Получив на вход {оригинальные fidd-файл, fidd.key-файл}, а также []{fidd-файл и fidd.key-файл обновлений}, восстанавливает директорию с обновлениями.

### 5.3 Перепаковка (Squash)

- Получив на вход {оригинальные fidd-файл, fidd.key-файл}, а также []{fidd-файл и fidd.key-файл обновлений}, создает перепакованный {fidd-файл и fidd.key-файл}, с контентом последней обновленной версии. При этом сохраняет идентификатор fidd-поста и увеличивает версию на 1, то есть продолжает историю.  
Полезно, если количество обновлений стало слишком велико (при этом улучшится стриминг).
Операция сходна с git squash.

### 5.4 Фичи

- Возможность выбора алгоритмов шифрования, при необходимости указывая свой для каждого файла;
- Возможность удобного расширения набора алгоритмов шифрования своими;
- Рандомизация размещения логических файлов - указать размер хедера/футера/гепа (от X байт - до Y байт);
- Выбор наилучшего варианта при создании обновлений (по размеру) - тип алгоритма diff или же полное обновление логического файла (override);
- и пр.

## 6. Развитие формата

Данный документ описывает общие требования и отдельные предложения к имплементации формата fidd, но не является законченным техническим стандартом, работа в процессе.  
Более того, мы не исключаем, что данный формат может пройти несколько эволюционных шагов, поэтому имеет смысл говорить именно о версиях формата.  
Наш эффорт, направленный на реализацию версии, следующюю принципам, описанным в данном документе, мы назовем fidd 1.0.

### 6.1 Хранение версии:

Из секции 4 видно, что в целях безопасности сам fidd-файл не будет хранить версии своего формата, данная информация будет находиться в fidd.key.
Действительно, какой смысл знать версию формата файла без ключа, которым этот файл открывается.

Возможно также отдельное версионирование формата fidd, fidd.key и file metadata. Тогда общая версия формата будет составной.  
Например, `1.0:1.3:2.5`
- формат fidd-файла 1.0
- формат fidd.key-файла 1.3
- формат file metadata 2.5

## Appendix A: Fidd Format Diagram

![Fidd Format Diagram.png](Fidd%20Format%20Diagram.png)